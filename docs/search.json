[
  {
    "objectID": "01.html",
    "href": "01.html",
    "title": "1  The Deep Learning Revolution",
    "section": "",
    "text": "1.1 the impact of DL (4)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Deep Learning Revolution</span>"
    ]
  },
  {
    "objectID": "01.html#the-impact-of-dl-4",
    "href": "01.html#the-impact-of-dl-4",
    "title": "1  The Deep Learning Revolution",
    "section": "",
    "text": "1.1.1 midical diagnosis\n\n\n\n1.1.2 protein structure\n\n\n\n1.1.3 image synthesis\n\n\n\n1.1.4 LLM",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Deep Learning Revolution</span>"
    ]
  },
  {
    "objectID": "01.html#a-tutorial-example-6",
    "href": "01.html#a-tutorial-example-6",
    "title": "1  The Deep Learning Revolution",
    "section": "1.2 a tutorial example (6)",
    "text": "1.2 a tutorial example (6)\n\n1.2.1 synthetic data\n\n\n\n1.2.2 linear models\n\n\n1.2.3 error function\n\n\n\n1.2.4 model complexity\n      \n\n\n1.2.5 regularization\n  \n\n\n1.2.6 model selection",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Deep Learning Revolution</span>"
    ]
  },
  {
    "objectID": "01.html#a-brief-history-of-ml",
    "href": "01.html#a-brief-history-of-ml",
    "title": "1  The Deep Learning Revolution",
    "section": "1.3 a brief history of ML",
    "text": "1.3 a brief history of ML\n\n\n1.3.1 single layer networks\n\n\n\n1.3.2 backpropagation\n\n\n\n1.3.3 deep networks",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Deep Learning Revolution</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dlfc_notes",
    "section": "",
    "text": "Preface\nThis project is a WIP.\nI’m a great fan of Bishop’s 2006 book, Pattern Recognition and Machine Learning (PRML), so as an AI practioner coming from a Bayesian background, I’m very much pleasantly surprised to learn that Bishop (and Bishop) have published a new book dedicated to deep learning and artificial intelligence. The focus on generative models is especially enticing, firstly because it is all the rage for the moment; secondly for a Bayesian statistician, doing generative modeling has always been what we are trained for.\nThe book has 20 chapters, I have divided them roughly into three parts.\n\nFoundations: chapters 1-5, covers the basics of machine learning.\nDeep Learning: chapters 6-13, covers the nuts and bolts of deep learning.\nGenerative Models: chapters 14-20, covers generative modeling and some common model architectures.\n\nHerein collected are my notes on the book, and the code to implement the examples in the book. Since these are my understanding of the book, they might not be completely accurate, so please refer to the book for the authoritative source. And if you find any errors, do let me know!\nThe notes and code are written in a literate programming style (See Knuth (1984) for additional discussion). The references are not complete; I only included the ones I have read.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "18.html",
    "href": "18.html",
    "title": "3  Normalizing Flows",
    "section": "",
    "text": "3.1 coupling flows\nRecall that in flow models we aim for the following goals:\nEach flow model will attempt to meet these goals in different ways. In coupling flows, for each layer of the network, we first split the latent variable \\(\\mathbf{z}\\) into two parts \\(\\mathbf{z} = (\\mathbf{z}_A, \\mathbf{z}_B)\\), then apply the following transformation:\n\\[\n\\begin{align}\n\\mathbf{X}_A &= \\mathbf{Z}_A, \\\\\n\\mathbf{X}_B &= \\exp(s(\\mathbf{Z}_A, w)) \\odot \\mathbf{Z}_B + b(\\mathbf{Z}_A, w).\n\\end{align}\n\\]\nThe frist part \\(\\mathbf{X}_A\\) is simply left unchanged, and all the efforts are put into transforming the second part \\(\\mathbf{X}_B\\). The transformation is done by a neural network with parameters \\(w\\), which takes \\(\\mathbf{Z}_A\\) as input and outputs two vectors \\(s(\\mathbf{Z}_A, w)\\) and \\(b(\\mathbf{Z}_A, w)\\) of the same dimensionality as \\(\\mathbf{Z}_B\\). Besides, an \\(\\exp\\) function is used to ensure that the Jacobian determinant is easy to compute.\nNow let’s check how this formula meets the three aformentioned goals. First is invertability. Simply rearrange the terms and we can get the inverse transformation:\n\\[\n\\begin{align}\n\\mathbf{Z}_A &= \\mathbf{X}_A, \\\\\n\\mathbf{Z}_B &= (\\mathbf{X}_B - b(\\mathbf{X}_A, w)) \\odot \\exp(-s(\\mathbf{X}_A, w)).\n\\end{align}\n\\]\nNotice how the inverse transformation does not involve inverting the neural networks at all, just changing the sign of the \\(\\exp\\) function. This is the key to making the transformation invertible easy and efficient.\nSecond is computing the Jacobian determinant. It turns out the Jacobian is a lower trianglular matrix\n\\[\n\\begin{bmatrix}\n\\mathbf{I} & 0 \\\\\n\\frac{\\partial \\mathbf{Z}_B}{\\partial \\mathbf{X}_A} & \\text{diag}(-\\exp(s(\\mathbf{Z}_A, w)))\n\\end{bmatrix}\n\\]\nand the determinant is simply the product of the diagonal elements.\nTo make the network more expressive, normalizing flows often have multiple coupling layers stacked together, switching the roles of \\(\\mathbf{Z}_A\\) and \\(\\mathbf{Z}_B\\) at each layer, and possibly also changing the split points at each layer. The final data likelihood is the product of the likelihoods at each layer. And the Jacobian determinant is the product of the determinants at each layer.\nThird is sampling. Once the model is trained, we can start with \\(\\mathbf{Z}_A\\), and follow the flow till we get to \\(\\mathbf{X}\\). The sampling process is deterministic and easy to compute.\nAs an example we can train a normalizing flow model on a two-moons dataset, using the normflows package. The following code is adapted from the package’s example code.\n# Import required packages\nimport torch\nimport numpy as np\nimport normflows as nf\nfrom matplotlib import pyplot as plt\nfrom tqdm import tqdm\ndevice = 'cuda'\nThis is the target distribution\n# Define target distribution\ntarget = nf.distributions.TwoMoons()\n# Plot target distribution\ngrid_size = 200\nxx, yy = torch.meshgrid(torch.linspace(-3, 3, grid_size), torch.linspace(-3, 3, grid_size), indexing='xy')\nzz = torch.cat([xx.unsqueeze(2), yy.unsqueeze(2)], 2).view(-1, 2)\nzz = zz.to(device)\n\nlog_prob = target.log_prob(zz).to('cpu').view(*xx.shape)\nprob = torch.exp(log_prob)\nprob[torch.isnan(prob)] = 0\n\nplt.pcolormesh(xx, yy, prob.data.numpy(), cmap='hot')\nplt.gca().set_aspect('equal', 'box')\nConstruct the model. To define a normalizing flow model, we first specify the base distribution and the transformation layers, and then combine them in the NormalizingFlow class.\n# Define 2D Gaussian base distribution\nbase = nf.distributions.base.DiagGaussian(2)\n\n# Define list of flows\nnum_layers = 2\nflows = []\nfor i in range(num_layers):\n    # Neural network with two hidden layers having 64 units each\n    # Last layer is initialized by zeros making training more stable\n    param_map = nf.nets.MLP([1, 64, 64, 2], init_zeros=True)\n    # Add flow layer\n    flows.append(nf.flows.AffineCouplingBlock(param_map))\n    # Swap dimensions\n    flows.append(nf.flows.Permute(2, mode='swap'))\n\nmodel = nf.NormalizingFlow(base, flows)\nmodel = model.to(device)\nTrain the model.\nmax_iter = 3201\nnum_samples = 2 ** 9\nshow_iter = 800\n\nloss_hist = np.array([])\nprob_list = []\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-4, weight_decay=1e-5)\n\nfor it in tqdm(range(max_iter)):\n    optimizer.zero_grad()\n\n    # Get training samples\n    x = target.sample(num_samples).to(device)\n\n    # Compute loss\n    loss = model.forward_kld(x)\n\n    # Do backprop and optimizer step\n    if ~(torch.isnan(loss) | torch.isinf(loss)):\n        loss.backward()\n        optimizer.step()\n\n    # Log loss\n    loss_hist = np.append(loss_hist, loss.to('cpu').data.numpy())\n\n    # Save prob for later plotting\n    if it % show_iter == 0:\n        model.eval()\n        log_prob = model.log_prob(zz)\n        model.train()\n        prob = torch.exp(log_prob.to('cpu').view(*xx.shape))\n        prob[torch.isnan(prob)] = 0\n        prob_list.append(prob.data.numpy())\nplt.plot(loss_hist)\n\n  0%|          | 0/3201 [00:00&lt;?, ?it/s]  0%|          | 15/3201 [00:00&lt;00:21, 149.57it/s]  2%|▏         | 64/3201 [00:00&lt;00:09, 348.03it/s]  3%|▎         | 111/3201 [00:00&lt;00:07, 400.08it/s]  5%|▍         | 157/3201 [00:00&lt;00:07, 420.78it/s]  6%|▋         | 202/3201 [00:00&lt;00:06, 430.97it/s]  8%|▊         | 248/3201 [00:00&lt;00:06, 438.31it/s]  9%|▉         | 294/3201 [00:00&lt;00:06, 442.53it/s] 11%|█         | 339/3201 [00:00&lt;00:06, 444.55it/s] 12%|█▏        | 384/3201 [00:00&lt;00:06, 446.14it/s] 13%|█▎        | 430/3201 [00:01&lt;00:06, 448.35it/s] 15%|█▍        | 475/3201 [00:01&lt;00:06, 448.17it/s] 16%|█▌        | 520/3201 [00:01&lt;00:05, 447.81it/s] 18%|█▊        | 566/3201 [00:01&lt;00:05, 448.81it/s] 19%|█▉        | 611/3201 [00:01&lt;00:05, 445.47it/s] 20%|██        | 656/3201 [00:01&lt;00:05, 446.51it/s] 22%|██▏       | 701/3201 [00:01&lt;00:05, 446.64it/s] 23%|██▎       | 746/3201 [00:01&lt;00:05, 446.91it/s] 25%|██▍       | 791/3201 [00:01&lt;00:05, 447.78it/s] 26%|██▌       | 836/3201 [00:01&lt;00:05, 438.08it/s] 28%|██▊       | 881/3201 [00:02&lt;00:05, 441.20it/s] 29%|██▉       | 926/3201 [00:02&lt;00:05, 441.27it/s] 30%|███       | 971/3201 [00:02&lt;00:05, 442.14it/s] 32%|███▏      | 1017/3201 [00:02&lt;00:04, 444.51it/s] 33%|███▎      | 1062/3201 [00:02&lt;00:04, 444.95it/s] 35%|███▍      | 1107/3201 [00:02&lt;00:04, 446.39it/s] 36%|███▌      | 1152/3201 [00:02&lt;00:04, 446.95it/s] 37%|███▋      | 1197/3201 [00:02&lt;00:04, 443.93it/s] 39%|███▉      | 1242/3201 [00:02&lt;00:04, 445.48it/s] 40%|████      | 1287/3201 [00:02&lt;00:04, 445.54it/s] 42%|████▏     | 1332/3201 [00:03&lt;00:04, 446.29it/s] 43%|████▎     | 1377/3201 [00:03&lt;00:04, 445.23it/s] 44%|████▍     | 1422/3201 [00:03&lt;00:04, 444.74it/s] 46%|████▌     | 1467/3201 [00:03&lt;00:03, 446.30it/s] 47%|████▋     | 1512/3201 [00:03&lt;00:03, 446.52it/s] 49%|████▊     | 1557/3201 [00:03&lt;00:03, 446.73it/s] 50%|█████     | 1602/3201 [00:03&lt;00:03, 444.11it/s] 51%|█████▏    | 1647/3201 [00:03&lt;00:03, 441.48it/s] 53%|█████▎    | 1692/3201 [00:03&lt;00:03, 443.78it/s] 54%|█████▍    | 1737/3201 [00:03&lt;00:03, 445.33it/s] 56%|█████▌    | 1782/3201 [00:04&lt;00:03, 445.83it/s] 57%|█████▋    | 1828/3201 [00:04&lt;00:03, 447.55it/s] 59%|█████▊    | 1873/3201 [00:04&lt;00:02, 447.12it/s] 60%|█████▉    | 1918/3201 [00:04&lt;00:02, 447.26it/s] 61%|██████▏   | 1963/3201 [00:04&lt;00:02, 447.33it/s] 63%|██████▎   | 2008/3201 [00:04&lt;00:02, 447.37it/s] 64%|██████▍   | 2053/3201 [00:04&lt;00:02, 447.26it/s] 66%|██████▌   | 2098/3201 [00:04&lt;00:02, 447.30it/s] 67%|██████▋   | 2143/3201 [00:04&lt;00:02, 447.96it/s] 68%|██████▊   | 2188/3201 [00:04&lt;00:02, 448.04it/s] 70%|██████▉   | 2234/3201 [00:05&lt;00:02, 448.40it/s] 71%|███████   | 2279/3201 [00:05&lt;00:02, 447.09it/s] 73%|███████▎  | 2324/3201 [00:05&lt;00:01, 446.44it/s] 74%|███████▍  | 2370/3201 [00:05&lt;00:01, 447.81it/s] 75%|███████▌  | 2415/3201 [00:05&lt;00:01, 444.66it/s] 77%|███████▋  | 2461/3201 [00:05&lt;00:01, 447.19it/s] 78%|███████▊  | 2506/3201 [00:05&lt;00:01, 445.27it/s] 80%|███████▉  | 2551/3201 [00:05&lt;00:01, 445.60it/s] 81%|████████  | 2596/3201 [00:05&lt;00:01, 446.04it/s] 83%|████████▎ | 2642/3201 [00:05&lt;00:01, 446.93it/s] 84%|████████▍ | 2687/3201 [00:06&lt;00:01, 444.15it/s] 85%|████████▌ | 2732/3201 [00:06&lt;00:01, 444.66it/s] 87%|████████▋ | 2777/3201 [00:06&lt;00:00, 445.03it/s] 88%|████████▊ | 2822/3201 [00:06&lt;00:00, 445.70it/s] 90%|████████▉ | 2867/3201 [00:06&lt;00:00, 446.12it/s] 91%|█████████ | 2912/3201 [00:06&lt;00:00, 446.45it/s] 92%|█████████▏| 2957/3201 [00:06&lt;00:00, 440.97it/s] 94%|█████████▍| 3002/3201 [00:06&lt;00:00, 442.14it/s] 95%|█████████▌| 3047/3201 [00:06&lt;00:00, 442.77it/s] 97%|█████████▋| 3092/3201 [00:06&lt;00:00, 444.39it/s] 98%|█████████▊| 3137/3201 [00:07&lt;00:00, 445.22it/s] 99%|█████████▉| 3182/3201 [00:07&lt;00:00, 445.20it/s]100%|██████████| 3201/3201 [00:07&lt;00:00, 442.53it/s]\nPlot the results. We can see that the model has (roughly) learned the distribution of the two moons dataset.\nfig, axes = plt.subplots(1, len(prob_list), figsize=(10, 2), sharey=True)\nfor i, prob in enumerate(prob_list):\n    ax = axes[i]\n    c = ax.pcolormesh(xx, yy, prob, cmap='hot')\n    ax.set_aspect('equal', 'box')\n\n# Adjust the colorbar to have more padding\ncbar = fig.colorbar(c, ax=axes, orientation='vertical', fraction=0.02, pad=0.02)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Normalizing Flows</span>"
    ]
  },
  {
    "objectID": "18.html#coupling-flows",
    "href": "18.html#coupling-flows",
    "title": "3  Normalizing Flows",
    "section": "",
    "text": "The transformation function \\(f\\) should be (easily enough) invertible, so that we can compute the latent variable likelihood.\nThe Jacobian determinant of the transformation should be easy to compute, so that we can correct the latent likelihood to get the data likelihood.\nWe should be able to sample from it. Once the above two are met, this is usually straightforward, although the computation cost might vary.\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{Z}_A\\) is an identity transformation of \\(\\mathbf{X}_A\\), so \\(\\frac{\\partial \\mathbf{Z}_A}{\\partial \\mathbf{X}_A}\\) is an identity matrix.\n\\(\\frac{\\partial \\mathbf{Z}_A}{\\partial \\mathbf{X}_B}\\) is zero.\n\\(\\mathbf{Z}_B\\) is \\(\\mathbf{X}_B\\) minus a linear transformation of \\(\\mathbf{X}_A\\) (doesn’t involve \\(\\mathbf{Z}_B\\)), then element-wise multiplied by the exponential term (meaning no interaction among \\(\\mathbf{Z}_B\\)), so \\(\\frac{\\partial \\mathbf{Z}_B}{\\partial \\mathbf{X}_B}\\) is a diagonal matrix, and the diagonal values are the corresponding negatives of the exponential term. Up to this point we know the Jacobian matrix itselve is a lower triangular matrix.\n\\(\\frac{\\partial \\mathbf{Z}_B}{\\partial \\mathbf{X}_A}\\) is more complicated, but it doesn’t factor into the Jacobian determinant so can be safely ignored.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Normalizing Flows</span>"
    ]
  },
  {
    "objectID": "18.html#autoregressive-flows",
    "href": "18.html#autoregressive-flows",
    "title": "3  Normalizing Flows",
    "section": "3.2 autoregressive flows",
    "text": "3.2 autoregressive flows",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Normalizing Flows</span>"
    ]
  },
  {
    "objectID": "18.html#continuous-flows",
    "href": "18.html#continuous-flows",
    "title": "3  Normalizing Flows",
    "section": "3.3 continuous flows",
    "text": "3.3 continuous flows\nIn normalizing flow models, for each transformation layer, the input and output always have the same dimensionality, we are thus looking for a more meaningful representation of the same data space. There is another neural network sharing this property, namely residual networks, but there is no guarantee that such a network will be invertible. Here we introduce a well known mathematical concept, the differential equation, into the neural network, and thus satisfying both the invertibility and the constant dimensionality requirements.\n\n3.3.1 neural differential equation\nNeural differential equation, as the name implies, is a neural network that is defined by a differential equation. We can consider the residual network as a discrete version of the differential equation, since the “residual” is already a difference between consecutive layers, and the differential is the limit of this difference as it approaches zero. Thus starting from a residual network\n\\[\n\\mathbf{z}_{t+1} = \\mathbf{z}_t + f(\\mathbf{z}_t, \\mathbf{w})\n\\]\nwe can readily convert it into a differential equation\n\\[\n\\frac{d\\mathbf{z(t)}}{dt} = f(\\mathbf{z(t)}, \\mathbf{w}).\n\\]\nNow defining something is easy, what really matters is what we can do with it. On the modeling side, starting from an initial state \\(\\mathbf{z}_0\\), we no longer need to define the number of layers in the network. we can integrate the differential equation to get the state at any time \\(t\\),\n\n\n\n3.3.2 neural ODE backpropagation\n\n\n3.3.3 neural ODE flows",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Normalizing Flows</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "20.html",
    "href": "20.html",
    "title": "3  Diffusion Models",
    "section": "",
    "text": "3.1 forward encoder\nfollowing the Bayesian tradition, we denote the hidden variables, i.e. the noisy images as z, and the observed image as x.\nthe forward encoder transforms an image to pure Gaussian noise, by adding some noise to the image at each step.\n\\[\nq(\\mathbf{z}_1 | \\mathbf{x}) = \\mathcal{N}(\\mathbf{z}_1 | \\sqrt{1 - \\boldsymbol{\\beta} _1} \\mathbf{x}, \\boldsymbol{\\beta}_1 \\mathbf{I}).\n\\]\n\\[\nq(\\mathbf{z}_t | \\mathbf{z}_{t-1}) = \\mathcal{N}(\\mathbf{z}_t | \\sqrt{1 - \\boldsymbol{\\beta}_t} \\, \\mathbf{z}_{t-1}, \\boldsymbol{\\beta}_t \\mathbf{I}).\n\\]\nWe then calculate the conditional (on observed data) distributions of the hidden variables, and derive the reverse conditional (on next step hidden variable) distribution using Bayes’ rule.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diffusion Models</span>"
    ]
  },
  {
    "objectID": "20.html#forward-encoder",
    "href": "20.html#forward-encoder",
    "title": "3  Diffusion Models",
    "section": "",
    "text": "3.1.1 diffusion kernel\nbecause each step of the transformation is Gaussian, we can combine the Gaussian transformations between any two random points in time; for this reason, we can derive the hidden variable distribution at any time using just the original image, and the noise schedule up to that time.\n\\[\nq(\\mathbf{z}_1, \\ldots, \\mathbf{z}_t | \\mathbf{x}) = q(\\mathbf{z}_1 | \\mathbf{x}) \\prod_{\\tau=2}^{t} q(\\mathbf{z}_{\\tau} | \\mathbf{z}_{\\tau-1}). \\quad (20.5)\n\\]\n\\[\nq(\\mathbf{z}_t | \\mathbf{x}) = \\mathcal{N}(\\mathbf{z}_t | \\sqrt{\\alpha_t} \\mathbf{x}, (1 - \\alpha_t) \\mathbf{I}). \\quad (20.6)\n\\]\n\\[\n\\alpha_t = \\prod_{\\tau=1}^{t} (1 - \\beta_{\\tau}). \\quad (20.7)\n\\]\n\\[\n\\mathbf{z}_t = \\sqrt{\\alpha_t} \\mathbf{x} + \\sqrt{1 - \\alpha_t} \\boldsymbol{\\epsilon}_t \\quad (20.8)\n\\]\n\\[\nq(\\mathbf{z}_T | \\mathbf{x}) = \\mathcal{N}(\\mathbf{z}_T | \\mathbf{0}, \\mathbf{I}) \\quad (20.9)\n\\]\n\\[\nq(\\mathbf{z}_T) = \\mathcal{N}(\\mathbf{z}_T | \\mathbf{0}, \\mathbf{I}). \\quad (20.10)\n\\]\nsince the final hidden variable is pure Gaussian noise, it does not depend on any other variable.\n\n\n3.1.2 conditional distribuitons\nafter specifying the diffusion kernel, it is of interest to reverse the process, to arrive at the original image from pure Gaussian noise.\nsince we already have the forward diffusion kernel, to get the reverse distribution we’ll turn to the Bayes’ rule, as we have done many times before, and as we’ll do many times after.\nhowever this turns out to be intractable, because to obtain the reverse conditional distribution, from zt to zt-1, we need the marginal distribution of zt-1, but this is impossible, since we have to integrate over the unknown data distribution.\n\\[\nq(\\mathbf{z}_{t-1} | \\mathbf{z}_t) = \\frac{q(\\mathbf{z}_t | \\mathbf{z}_{t-1})q(\\mathbf{z}_{t-1})}{q(\\mathbf{z}_t)} \\quad (20.11)\n\\]\n\\[\nq(\\mathbf{z}_{t-1}) = \\int q(\\mathbf{z}_{t-1} | \\mathbf{x})p(\\mathbf{x}) \\, d\\mathbf{x} \\quad (20.12)\n\\]\na more meleable problem is to obtain the reverse conditional distribution, while also conditioning on the observed image data. This is doable (if the observed data is available), since this is exactly the diffusion kernel we obtained in section 20.1.1.\n\\[\nq(\\mathbf{z}_{t-1} | \\mathbf{z}_t, \\mathbf{x}) = \\frac{q(\\mathbf{z}_t | \\mathbf{z}_{t-1}, \\mathbf{x})q(\\mathbf{z}_{t-1} | \\mathbf{x})}{q(\\mathbf{z}_t | \\mathbf{x})} \\quad (20.13)\n\\]\n\\[\nq(\\mathbf{z}_t | \\mathbf{z}_{t-1}, \\mathbf{x}) = q(\\mathbf{z}_t | \\mathbf{z}_{t-1}) \\quad (20.14)\n\\]\n\\[\nq(\\mathbf{z}_{t-1} | \\mathbf{z}_t, \\mathbf{x}) = \\mathcal{N}(\\mathbf{z}_{t-1} | \\mathbf{m}_t(\\mathbf{x}, \\mathbf{z}_t), \\sigma_t^2 \\mathbf{I}) \\quad (20.15)\n\\]\nall the distributions involved are Gaussian, so the density function can be solved analytically (by completing the square)\n\\[\n\\mathbf{m}_t(\\mathbf{x}, \\mathbf{z}_t) = \\frac{(1 - \\alpha_{t-1}) \\sqrt{1 - \\beta_t}\\mathbf{z}_t + \\sqrt{ \\alpha_{t-1}} \\beta_t\\mathbf{x}}{1 - \\alpha_t} \\quad (20.16)\n\\]\n\\[\n\\sigma_t^2 = \\frac{\\beta_t(1 - \\alpha_{t-1})}{1 - \\alpha_t} \\quad (20.17)\n\\]\nthis is very neat but when we generate new data from the model we don’t normally already have the image we want. for this reason we learn a neural network to do the generation instead.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diffusion Models</span>"
    ]
  },
  {
    "objectID": "20.html#reverse-decoder",
    "href": "20.html#reverse-decoder",
    "title": "3  Diffusion Models",
    "section": "3.2 reverse decoder",
    "text": "3.2 reverse decoder\nSo the basic idea is to find a distribution p to approximate reverse distribution q. We’ll parameterise p with a deep neural network and train it to optimise the parameters, so that when the original data is available, the conditional distribution can reproduce the original image as faithfully as possible; and when origial image not available, the model has been well trained to generate images from the data distribution.\n\\[\np(\\mathbf{z}_{t-1} | \\mathbf{z}_t, \\mathbf{w}) = \\mathcal{N}(\\mathbf{z}_{t-1} | \\mathbf{\\mu} (\\mathbf{z}_t, \\mathbf{w}, t), \\beta_t \\mathbf{I}) \\quad (20.18)\n\\]\n\\[\np(\\mathbf{x}, \\mathbf{z}_1, \\ldots, \\mathbf{z}_T | \\mathbf{w}) = p(\\mathbf{z}_T) \\prod_{t=2}^{T} p(\\mathbf{z}_{t-1} | \\mathbf{z}_t, \\mathbf{w}) \\, p(\\mathbf{x} | \\mathbf{z}_1, \\mathbf{w}) \\quad (20.19)\n\\]\n \n \nthe reverse conditional distribution, parameterised by a deep neural network\nthe joint distribution of the reverse process, parameterised by the deep neural network\n\n3.2.1 training the decoder\nto train the network, our first attempt is to directly maximise the data likelihood, which can be obtained by marginaling out the hidden variables.\nthis is clearly impossible, since we’d need the posterior in the first place.\n\\[\np(\\mathbf{x}|\\mathbf{w}) = \\int \\cdots \\int p(\\mathbf{x}, \\mathbf{z}_1, \\ldots, \\mathbf{z}_T|\\mathbf{w}) \\, d\\mathbf{z}_1 \\cdots d\\mathbf{z}_T \\quad (20.20)\n\\]\n\n\n3.2.2 evidence lower bound\nas a second attempt, we’ll decompose the data likelihood function into two terms, the ELBO term and the KL divergence term.\nThis can be done, again, by applying the good old rules of probability. Here we decompose the joint distribution of {{observed and hidden}} variables.\n\\[\np(\\mathbf{x},\\mathbf{z}|\\mathbf{w}) = p(\\mathbf{x}|\\mathbf{z},\\mathbf{w})p(\\mathbf{z}|\\mathbf{w}) \\quad (20.24)\n\\]\n\\[\np(\\mathbf{x}|\\mathbf{w}) = \\frac{p(\\mathbf{x},\\mathbf{z}|\\mathbf{w})}{p(\\mathbf{z}|\\mathbf{x},\\mathbf{w})}\n\\]\ntaking the log, and integrate over the hidden variables give us\n\\[\n\\begin{aligned}\n\\ln p(\\mathbf{x}|\\mathbf{w}) &= \\int q(\\mathbf{z}) \\ln p(\\mathbf{x}|\\mathbf{w}) \\, d\\mathbf{z} \\\\\n&= \\int q(\\mathbf{z}) \\ln \\frac{p(\\mathbf{x},\\mathbf{z}|\\mathbf{w})}{p(\\mathbf{z}|\\mathbf{x},\\mathbf{w})} \\, d\\mathbf{z} \\\\\n&= \\int q(\\mathbf{z}) \\ln \\frac{p(\\mathbf{x},\\mathbf{z}|\\mathbf{w}) q(\\mathbf{z})}{p(\\mathbf{z}|\\mathbf{x},\\mathbf{w}) q(\\mathbf{z})} \\, d\\mathbf{z} \\\\\n&= \\int q(\\mathbf{z}) \\ln \\frac{p(\\mathbf{x},\\mathbf{z}|\\mathbf{w})}{q(\\mathbf{z})} \\, d\\mathbf{z} - \\int q(\\mathbf{z}) \\ln \\frac{p(\\mathbf{z}|\\mathbf{x},\\mathbf{w})}{q(\\mathbf{z})} \\, d\\mathbf{z} \\\\\n&= \\mathcal{L}(\\mathbf{w}) + \\text{KL}(q(\\mathbf{z})||p(\\mathbf{z}|\\mathbf{x},\\mathbf{w})) \\quad (20.21)\n\\end{aligned}\n\\]\nthe KL divergence term is the difference between two distributions, the model of hidden variables, and an approximate posterior of choice.\n\\[\n\\text{KL}(q(\\mathbf{z})||p(\\mathbf{z}|\\mathbf{x},\\mathbf{w})) = -\\int q(\\mathbf{z}) \\ln \\frac{p(\\mathbf{z}|\\mathbf{x},\\mathbf{w})}{q(\\mathbf{z})} \\, d\\mathbf{z} \\quad (20.23)\n\\]\nthe ELBO term is another integral term, integrating over the same approximate posterior. We can use the ELBO as a surrogate target, because the KL divergence term is non-negative, as such maximising ELBO also maximises the data likelihood.\n\\[\n\\mathcal{L}(\\mathbf{w}) = \\int q(\\mathbf{z}) \\ln \\frac{p(\\mathbf{x}, \\mathbf{z}|\\mathbf{w})}{q(\\mathbf{z})} \\, d\\mathbf{z} \\quad (20.22)\n\\]\nby lower bound we mean\n\\[\n\\ln p(\\mathbf{x}|\\mathbf{w}) \\geq \\mathcal{L}(\\mathbf{w}) \\quad (20.25)\n\\]\nNow let’s take write out the ELBO and take a close look at its components.\n\\[\n\\begin{aligned}\n\\mathcal{L}(\\mathbf{w}) &= \\mathbb{E}_{q} \\left[ \\ln \\frac{p(\\mathbf{z}_T) \\prod_{t=2}^{T}p(\\mathbf{z}_{t-1}|\\mathbf{z}_t, \\mathbf{w}) p(\\mathbf{x} | \\mathbf{z}_1, \\mathbf{w}) }{q(\\mathbf{z}_1|\\mathbf{x}) \\prod_{t=2}^{T}q(\\mathbf{z}_t|\\mathbf{z}_{t-1} , \\mathbf{x})} \\right] \\\\\n&= \\mathbb{E}_{q} \\left[ \\ln p(\\mathbf{z}_T) + \\sum_{t=2}^{T} \\ln \\frac{p(\\mathbf{z}_{t-1}|\\mathbf{z}_t, \\mathbf{w})}{q(\\mathbf{z}_{t}|\\mathbf{z}_{t-1}, \\mathbf{x})} + \\ln p(\\mathbf{z}_1|\\mathbf{w}) + \\ln p(\\mathbf{x}|\\mathbf{z}_1, \\mathbf{w}) \\right] \\quad (20.26)\n\\end{aligned}\n\\]\nwhere \\[\n\\mathbb{E}_{q}[\\cdot] = \\int \\cdots \\int q(\\mathbf{z}_1|\\mathbf{x}) \\left[ \\prod_{t=2}^{T}q(\\mathbf{z}_t|\\mathbf{z}_{t-1}) \\right] [\\cdot] \\, d\\mathbf{z}_1 \\cdots d\\mathbf{z}_T \\quad (20.27)\n\\]\nNote that we can choose ANY approximate posterior function, but the one we ACTUALLY choose is the forward encoder distribution. This is no coincidence, we introduced the forward encoder, exactly for the purpose that it can be used here.\nThe first term of the ELBO is constant w.r.t. the model parameters and is thus ignored.\nFor the second term, we can first sample zt-1 using 20.3, then sample zt using 20.4, then we can compute p and q with no problem. This is procedurally right, however the estimation will be very noisy, since we consecutively did two sampling steps.\nThe third term is constant w.r.t. the model parameters and is thus ignored.\nFor the fourth term we can first sample z1 and then calculate the value.\n\\[\n\\mathbb{E}_{q}[\\ln p(\\mathbf{x}|\\mathbf{z}_1, \\mathbf{w})] \\approx \\frac{1}{L} \\sum_{l=1}^{L} \\ln p(\\mathbf{x}|\\mathbf{z}_1^{(l)}, \\mathbf{w}) \\quad (20.28)\n\\]\n\n\n3.2.3 rewriting the ELBO\nAs a third attempt, we will further decompose the second term of the ELBO, again by applying the good old rules of probability. This time we apply them on the joint distribution of the adjacent latent variables in the forward encoder.\nwe have the reverse process in the numerator, we want to also have the reverse process in the denominator to match it.\n\\[\nq(\\mathbf{z}_t | \\mathbf{z}_{t-1}, \\mathbf{x}) = \\frac{q(\\mathbf{z}_{t-1} | \\mathbf{z}_t, \\mathbf{x})q(\\mathbf{z}_t | \\mathbf{x})}{q(\\mathbf{z}_{t-1} | \\mathbf{x})} \\quad (20.29)\n\\]\n\\[\n\\ln \\frac{p(\\mathbf{z}_{t-1}|\\mathbf{z}_t, \\mathbf{w})}{q(\\mathbf{z}_t|\\mathbf{z}_{t-1}, \\mathbf{x})} = \\ln \\frac{p(\\mathbf{z}_{t-1}|\\mathbf{z}_t, \\mathbf{w})}{q(\\mathbf{z}_{t-1}|\\mathbf{z}_t, \\mathbf{x})} + \\ln \\frac{q(\\mathbf{z}_{t-1}|\\mathbf{x})}{q(\\mathbf{z}_t|\\mathbf{x})} \\quad (20.30)\n\\]\nThe second term on the RHS is independent of model parameters (remember they are defined by the forward encoder) and is thus ignored. The first term is two distributions of the same variable, so we are again dealing with a KL divergence term.\nUsing this, we can rewrite the ELBO as 20.31\nNow the ELBO consist of two terms, which we call the reconstruction term and the consistency term.\nThe reconstruction term is the logp weighted by z1, and thus measures how much we can reconstruct the data once the latent variable distribution is know. The consistency term is the KL divergence between the forward diffusion distribution and the reverse decoder network. So now we are finally able to connect what we need to compute, the (approximate) data likelihood, to what we have actually defined, the forward diffusion process and the backward denoising neural network. And we can happily proceed with the parameter optimization that we are so fond of.\nSince the two distributions in the KL divergence are both Gaussian, the divergence can be easily computed. 20.33\n\n\n3.2.4 predicting the noise\nwe are already able to optimize the model parameters, by matching the reverse denoising network to the forward diffusion network, by representing the KL devergence as the squared difference between the means of the forward and reverse process.\nit turns out we can use a simply trick, not modeling the mean of the reverse process, but the noise added to the latent variable, to improve the training and the generated image quality.\nit also turns out that when using this formulation, the reconstruction term can be viewd as a special case of the consistency term and merged together. So now we are left with a simple training procedure as follows:\n\n\n\n3.2.5 generating new samples",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diffusion Models</span>"
    ]
  },
  {
    "objectID": "20.html#score-matching",
    "href": "20.html#score-matching",
    "title": "3  Diffusion Models",
    "section": "3.3 score matching",
    "text": "3.3 score matching\nThe denoising diffusion models discussed so far in this chapter are closely related to another class of deep generative models that were developed relatively independently and which are based on score matching. These make use of the score function or Stein score, which is defined as the gradient of the log likelihood with respect to the data vector\nHere it is important to emphasize that the gradient is with respect to the data vector, not with respect to any parameter vector. Since the score function is the gradient wrt the input data\n\nit is vector-valued, and has the same dimensionality as the input.\nintegrating the score function over the data space gives the log data likelihood, up to a constant.\n\nSo if we parameterize the score function as s(x, w), optimize the parameters w so that the parameterized score matches the empirical data score, we have effectively modeled the data distribution. And if we can further generate samples using the parameterized score function, we have built a generative model of the data that we can sample from.\nFigure 20.5 shows an example of a probability density in two dimensions, along with the corresponding score function.\ndefine a model for the data, calculate the logp and the score function define a second model for the score, optimizing the parameters by matching the data score function do sampling using the parameterized score model\n \n\n3.3.1 score loss function\nthe training match the model score to the data distribution score.\n\\[\nJ(\\mathbf{w}) = \\frac{1}{2} \\int \\left\\| \\mathbf{s}(\\mathbf{x}, \\mathbf{w}) - \\nabla_{\\mathbf{x}} \\ln p(\\mathbf{x}) \\right\\|^2 p(\\mathbf{x}) \\, d\\mathbf{x} \\quad (20.43)\n\\]\nof course this is only theoretically; we don’t actually know the data distribution. we now move on to workarounds.\n\n\n3.3.2 modified score loss\nwe first approximate the data distribution with the empirical one \\[\np_{\\mathcal{D}}(\\mathbf{x}) = \\frac{1}{N} \\sum_{n=1}^{N} \\delta(\\mathbf{x} - \\mathbf{x}_n) \\quad (20.44)\n\\]\nsince the empirical distribution is not differentiable, we then smooth it with the Parzen estimator \\[\nq_{\\sigma}(\\mathbf{z}) = \\int q(\\mathbf{z} | \\mathbf{x}, \\sigma)p(\\mathbf{x}) \\, d\\mathbf{x} \\quad (20.47)\n\\]\nusing this result the loss function can be modified to \\[\nJ(\\mathbf{w}) = \\frac{1}{2N} \\sum_{n=1}^{N} \\int \\left\\| \\mathbf{s}(\\mathbf{z}, \\mathbf{w}) - \\nabla_{\\mathbf{z}} \\ln q(\\mathbf{z}|\\mathbf{x}_n, \\sigma) \\right\\|^2 q(\\mathbf{z}|\\mathbf{x}_n, \\sigma) \\, d\\mathbf{z} + \\text{const.} \\quad (20.51)\n\\]\nin the end, note we are matching scores of the latents, not the data.\n\n\n3.3.3 noise variance\n\n\n3.3.4 stochastic differential equations\nWe have seen that it is helpful to use a large number of steps, often several thousand, when constructing the noise process for a diffusion model. It is therefore natural to ask what happens if we consider the limit of an infinite number of steps, much as we did for infinitely deep neural networks when we introduced neural differential equations. In taking such a limit, we need to ensure that the noise variance \\(\\hat{\\beta}_t\\) at each step becomes smaller in keeping with the step size. This leads to a formulation of diffusion models for continuous time as stochastic differential equations. Both denoising diffusion probabilistic models and score matching models can then be viewed as a discretization of a continuous-time SDE.\nthe forward process We can write a general SDE as an infinitesimal update to the vector \\(\\mathbf{z}\\) in the form\n\\[\ndz = f(\\mathbf{z}, t) \\, dt + g(t) \\, d\\mathbf{v} \\quad (20.55)\n\\]\nwith drift and diffusion terms, respectively, where the drift term is deterministic, as in an ODE, but the diffusion term is stochastic, for example given by infinitesimal Gaussian steps. Here the parameter \\(t\\) is often called ‘time’ by analogy with physical systems. The forward noise process (20.3) for a diffusion model can be written as an SDE of the form (20.55) by taking the continuous-time limit.\nthe reverse process rooted in the time-reversibility of stochastic processes\nFor the SDE (20.55), there is a corresponding reverse SDE (Song et al., 2020) given by\n\\[\ndz = \\left\\{ f(\\mathbf{z}, t) - g^2(t) \\nabla_{\\mathbf{z}} \\ln p(\\mathbf{z}) \\right\\} dt + g(t) \\, d\\mathbf{v} \\quad (20.56)\n\\]\nwhere we recognize \\(\\nabla_{\\mathbf{z}} \\ln p(\\mathbf{z})\\) as the score function. The SDE given by (20.55) is to be solved in reverse from \\(t = T\\) to \\(t = 0\\).\nequal-spaced solver To solve an SDE numerically, we need to discretize the time variable. The simplest approach is to use fixed, equally spaced time steps, which is known as the Euler–Maruyama solver. For the reverse SDE, we then recover a form of the Langevin equation. However, more sophisticated solvers can be employed that use more flexible forms of discretization.\nadaptive-step solver For all diffusion processes governed by an SDE, there exists a corresponding deterministic process described by an ODE whose trajectories have the same marginal probability densities \\(p(\\mathbf{z}|t)\\) as the SDE (Song et al., 2020). For an SDE of the form (20.56), the corresponding ODE is given by\n\\[\n\\frac{d\\mathbf{z}}{dt} = f(\\mathbf{z}, t) - \\frac{1}{2} g^2(t) \\nabla_{\\mathbf{z}} \\ln p(\\mathbf{z}). \\quad (20.57)\n\\]\nThe ODE formulation allows the use of efficient adaptive-step solvers to reduce the number of function evaluations dramatically. Moreover, it allows probabilistic diffusion models to be related to normalizing flow models, from which the change-of-variables formula (18.1) can be used to provide an exact evaluation of the log likelihood.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diffusion Models</span>"
    ]
  },
  {
    "objectID": "20.html#guided-diffusion",
    "href": "20.html#guided-diffusion",
    "title": "3  Diffusion Models",
    "section": "3.4 Guided diffusion",
    "text": "3.4 Guided diffusion\n  \n\n3.4.1 classifier guidance\n\n\n3.4.2 classifier-free guidance",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diffusion Models</span>"
    ]
  },
  {
    "objectID": "07.html",
    "href": "07.html",
    "title": "2  Gradient Descent",
    "section": "",
    "text": "2.1 error surfaces\nerror function, local minimum A, global minimum B, and gradient at C",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gradient Descent</span>"
    ]
  },
  {
    "objectID": "07.html#error-surfaces",
    "href": "07.html#error-surfaces",
    "title": "2  Gradient Descent",
    "section": "",
    "text": "2.1.1 local quadratic approximation",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gradient Descent</span>"
    ]
  },
  {
    "objectID": "07.html#gradient-descent-optimisation",
    "href": "07.html#gradient-descent-optimisation",
    "title": "2  Gradient Descent",
    "section": "2.2 gradient descent optimisation",
    "text": "2.2 gradient descent optimisation\nsimply put, gradient descent initialize the weights somewhere, calculate an increment using gradient information, and modify the weights using this information.\n\\[\n\\mathbf{w}^{(\\tau)} = \\mathbf{w}^{(\\tau-1)} + \\Delta \\mathbf{w}^{(\\tau-1)}\n\\]\nthe bulk of our attention will be devoted to how to get the gradient, but the starting point is also quite important.\n\n2.2.1 use of gradient information\n\n\n2.2.2 batch gradient descent\n\n\n2.2.3 stochastic gradient descent\n\n\n2.2.4 mini-batches\n\n\n2.2.5 parameter initialisation",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gradient Descent</span>"
    ]
  },
  {
    "objectID": "07.html#convergence",
    "href": "07.html#convergence",
    "title": "2  Gradient Descent",
    "section": "2.3 convergence",
    "text": "2.3 convergence\n\n\n2.3.1 momentum\n  \n\n\n2.3.2 learning rate schedule\n\n\n2.3.3 RMSProp and Adam",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gradient Descent</span>"
    ]
  },
  {
    "objectID": "07.html#normalisation",
    "href": "07.html#normalisation",
    "title": "2  Gradient Descent",
    "section": "2.4 normalisation",
    "text": "2.4 normalisation\nThe gopher(2022) paper also introduced a RMSNorm normalisation method.\n\n2.4.1 data normalisation\n\n\n\n2.4.2 batch normalisation\n\n\n\n2.4.3 layer normalisation\n\n\nimport torch\nimport torch.nn as nn\nfrom einops import reduce\n\n# NLP Example\nbatch, sentence_length, embedding_dim = 2, 5, 3\nembedding = torch.randn(batch, sentence_length, embedding_dim)\nlayer_norm = nn.LayerNorm(embedding_dim)\n\n# Calculate mean before LayerNorm across all dimensions except batch\nmean_before = reduce(embedding, 'b s e -&gt; b', 'mean')\n\n# Calculate variance before LayerNorm across all dimensions except batch\nvar_before = reduce((embedding - mean_before.reshape(batch, 1, 1)) ** 2, 'b s e -&gt; b', 'mean')\n\n# Activate module\nnormalized_embedding = layer_norm(embedding)\n\n# Calculate mean after LayerNorm across all dimensions except batch\nmean_after = reduce(normalized_embedding, 'b s e -&gt; b', 'mean')\n\n# Calculate variance after LayerNorm across all dimensions except batch\nvar_after = reduce((normalized_embedding - mean_after.reshape(batch, 1, 1)) ** 2, 'b s e -&gt; b', 'mean')\n\n# Display mean and variance\nprint(\"Before LayerNorm - Mean: \", end=\"\")\nprint(*mean_before.tolist(), sep=\", \")\nprint(\"Before LayerNorm - Variance: \", end=\"\")\nprint(*var_before.tolist(), sep=\", \")\n\nprint(\"After LayerNorm - Mean: \", end=\"\")\nprint(*mean_after.tolist(), sep=\", \")\nprint(\"After LayerNorm - Variance: \", end=\"\")\nprint(*var_after.tolist(), sep=\", \")\n\nBefore LayerNorm - Mean: -0.1163964793086052, 0.16730044782161713\nBefore LayerNorm - Variance: 1.2326244115829468, 1.6592100858688354\nAfter LayerNorm - Mean: -7.947286384535346e-09, -7.947286384535346e-09\nAfter LayerNorm - Variance: 0.9999745488166809, 0.9999361634254456",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gradient Descent</span>"
    ]
  }
]